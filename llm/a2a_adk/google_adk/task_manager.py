import json
import logging
from abc import ABC, abstractmethod
from typing import Any, AsyncIterable, Dict, Union

from common.server.task_manager import InMemoryTaskManager
from common.server import utils
from common.types import (
    SendTaskRequest,
    TaskSendParams,
    Message,
    TaskStatus,
    Artifact,
    TaskStatusUpdateEvent,
    TaskArtifactUpdateEvent,
    TextPart,
    TaskState,
    Task,
    SendTaskResponse,
    InternalError,
    JSONRPCResponse,
    SendTaskStreamingRequest,
    SendTaskStreamingResponse,
)
from google.genai import types

logger = logging.getLogger(__name__)


class AgentWithTaskManager(ABC):
    """
    Abstract base class for agents that interact with a task manager.

    Defines the interface for agents to provide processing messages
    and invoke/stream responses based on user queries.
    """

    @abstractmethod
    def get_processing_message(self) -> str:
        """
        Returns a message indicating that the agent is processing the request.

        This message is typically displayed to the user while the agent is working.
        """
        pass

    def invoke(self, query: str, session_id: str) -> str:
        """
        Invokes the agent with the given query and session ID using the ADK/A2A interface.

        This method handles the core logic of sending a query to the agent,
        managing sessions, and returning the agent's response as a string.
        Args:
            query: The user's query as a string.  This is the input provided to the agent.
            session_id: The ID of the user's session.  Used to maintain context across multiple interactions.
        Returns:
            The agent's response as a string.  This is the final result generated by the agent.
            Returns an empty string if no response parts with text were found.
        """

        # Retrieve the session associated with the given app, user, and session ID.
        # If a session doesn't exist, it will return None.
        session = self._runner.session_service.get_session(
            app_name=self._agent.name, user_id=self._user_id, session_id=session_id
        )

        # Create a Content object representing the user's query.  This encapsulates the query
        # within the Google GenAI framework.
        content = types.Content(
            role="user", parts=[types.Part.from_text(text=query)]
        )

        # If a session doesn't exist, create a new one.  This ensures that the agent can maintain
        # state across multiple interactions with the user.
        if session is None:
            session = self._runner.session_service.create_session(
                app_name=self._agent.name,
                user_id=self._user_id,
                state={},
                session_id=session_id,
            )

        # Run the query against the agent's runner within the context of the session.
        # This is where the core processing of the query happens.  The `run` method
        # returns a generator of events. We convert to list to get all results
        events = list(self._runner.run(
            user_id=self._user_id, session_id=session.id, new_message=content
        ))

        # Extract the text from the last event's content parts.
        # We take the last event as it represents the final answer.
        # Returns empty string if no suitable parts are present
        if not events or not events[-1].content or not events[-1].content.parts:
            return ""
        return "\n".join([p.text for p in events[-1].content.parts if p.text])

    async def stream(self, query: str, session_id: str) -> AsyncIterable[Dict[str, Any]]:
        """
        Streams the agent's response to the given query and session ID.
        This method is used for ADK agent with A2A interface.

        Retrieves or creates a session, then runs the query against the agent's
        runner, yielding updates as they become available.

        Args:
            query: The user's query as a string.  This is the input provided to the agent.
            session_id: The ID of the user's session. Used to maintain context across multiple interactions.
        Yields:
            Dictionaries containing updates or the final response from the agent.
            Each dictionary has "is_task_complete" (bool) to signal finality.
            If not final, "updates" (str) contains processing messages.
            If final, "content" (str or dict) contains the response data.
        """
        # Retrieve the session associated with the given app, user, and session ID.
        # If a session doesn't exist, it will return None.
        session = self._runner.session_service.get_session(
            app_name=self._agent.name, user_id=self._user_id, session_id=session_id
        )

        # Create a Content object representing the user's query.  This encapsulates the query
        # within the Google GenAI framework.
        content = types.Content(
            role="user", parts=[types.Part.from_text(text=query)]
        )

        # If a session doesn't exist, create a new one.  This ensures that the agent can maintain
        # state across multiple interactions with the user.
        if session is None:
            session = self._runner.session_service.create_session(
                app_name=self._agent.name,
                user_id=self._user_id,
                state={},
                session_id=session_id,
            )

        # Run the query against the agent's runner within the context of the session, in async mode.
        # Yield updates as they become available using `run_async`.
        async for event in self._runner.run_async(
            user_id=self._user_id, session_id=session.id, new_message=content
        ):
            for i, p in enumerate(event.content.parts):
                print (f"ASD: Part {i}: ", p)

            # Check if the current event represents the final response from the agent.
            if event.is_final_response():
                # Initialize an empty string to hold the agent's response.
                response = ""

                # Check if the event contains text parts and construct the response.
                if (
                    event.content
                    and event.content.parts
                    and event.content.parts[0].text
                ):
                    print ("ASD: Agent Condition: part has text")
                    response = "\n".join([p.text for p in event.content.parts if p.text])
                # Check if the event contains function responses, retrieve and dump them as model.
                elif (
                    event.content
                    and event.content.parts
                    and any([True for p in event.content.parts if p.function_response])):
                    print ("ASD: Agent Condition: part has function response")
                    response = next((p.function_response.model_dump() for p in event.content.parts))

                elif (
                    event.content
                    and event.content.parts
                    and any([True for p in event.content.parts if p.code_execution_result])):
                    #response = next((str(p.executable_code) for p in event.content.parts))
                    response = str([p.code_execution_result.output for p in event.content.parts if p.code_execution_result])
                    print ("ASD: Agent Condition: part has code execution response", str(response))

                else:
                    # Ankur: Default for all other cases
                    print ("ASD: Agent Condition: Nothing else works")
                    response = "\n".join([p.text for p in event.content.parts if p.text])

                print ("Agent stream: Is Final]:: ", event.content.parts)
                # Yield a dictionary indicating task completion along with the response.
                yield {
                    "is_task_complete": True,
                    "content": response,
                }
            # If the event is not the final response, yield a processing update.
            else:
                print ("Agent stream: Is NOT Final]:: ", event)
                # Yield a dictionary indicating the task is still in progress and provides a processing message.
                yield {
                    "is_task_complete": False,
                    "updates": self.get_processing_message(),
                }


class AgentTaskManager(InMemoryTaskManager):
    """
    Manages tasks for a specific agent, extending the base InMemoryTaskManager.

    Handles task creation, updates, and invocation/streaming for an agent.
    Uses the provided AgentWithTaskManager to interact with the agent itself.
    """

    def __init__(self, agent: AgentWithTaskManager):
        """
        Initializes the AgentTaskManager with the given agent.

        Args:
            agent: The AgentWithTaskManager instance to manage tasks for.
        """
        super().__init__()
        self.agent = agent

    async def _stream_generator(
        self, request: SendTaskStreamingRequest
    ) -> AsyncIterable[SendTaskStreamingResponse] | JSONRPCResponse:
        """
        Generates a stream of SendTaskStreamingResponse objects for a given request.

        This method is the core of the streaming functionality.  It invokes the
        agent's stream method, processes the results, and yields appropriate
        response objects.
        Args:
            request: The SendTaskStreamingRequest object containing the task parameters.

        Yields:
            SendTaskStreamingResponse objects representing updates or the final result.
            JSONRPCResponse in case of an error.
        """
        task_send_params: TaskSendParams = request.params
        # Extract the user's query text from the request parameters.
        query = self._get_user_query(task_send_params)
        try:

          # Start the streaming process by calling the agent's stream method.
          # This iterates asynchronously over chunks/events yielded by the agent.
          async for item in self.agent.stream(query, task_send_params.sessionId):
            # Check if the current item/event from the agent is the final one.
            is_task_complete = item["is_task_complete"]
            artifacts = None

            # --- Handle Intermediate Updates ---
            if not is_task_complete:
              print ("A2A stream: Is Final]:: ", item)
              # Agent is still working, set state accordingly.
              task_state = TaskState.WORKING
              # Format the update message as a text part.
              parts = [{"type": "text", "text": item["updates"]}]

            # --- Handle Final Response ---
            else:
              print ("A2A stream: Is NOT Final]:: ", item)
              # Check if the final content is structured data (dict).
              if isinstance(item["content"], dict):
                # Specific check for form-like responses (e.g., from return_form tool).
                if ("response" in item["content"]
                    and "result" in item["content"]["response"]):
                  data = json.loads(item["content"]["response"]["result"])
                  # Form data usually requires user input.
                  task_state = TaskState.INPUT_REQUIRED
                else:
                  # Handle other types of dictionary content.
                  data = item["content"]
                  task_state = TaskState.COMPLETED
                # Format the dictionary content as a data part.
                parts = [{"type": "data", "data": data}]
              else:
                # Handle plain text final content.
                task_state = TaskState.COMPLETED
                # Format the text content as a text part.
                parts = [{"type": "text", "text": item["content"]}]
              # Bundle the final response parts into an Artifact.
              artifacts = [Artifact(parts=parts, index=0, append=False)]


          # --- Prepare and Send Updates/Artifacts ---
          # Create the message object for the current update/response.
          message = Message(role="agent", parts=parts)
          # Create the task status object.
          task_status = TaskStatus(state=task_state, message=message)

          # Update the internal task store with the latest status and any artifacts.
          # Note: This update happens *after* processing each item from the agent's stream.
          await self._update_store(task_send_params.id, task_status, artifacts)

          # Create the status update event to send back to the client.
          task_update_event = TaskStatusUpdateEvent(
                id=task_send_params.id,
                status=task_status,
                final=False,
            )
          # Yield the status update response.
          yield SendTaskStreamingResponse(id=request.id, result=task_update_event)

          # If artifacts were created (i.e., it was a final response), yield them.
          if artifacts:
            for artifact in artifacts:
              # Yield each artifact as a separate update event.
              yield SendTaskStreamingResponse(
                  id=request.id,
                  result=TaskArtifactUpdateEvent(
                      id=task_send_params.id,
                      artifact=artifact,
                  )
              )

          # If this was the final item from the agent stream, send a final status update.
          if is_task_complete:
            # Yield a final TaskStatusUpdateEvent to signal the end of this stream interaction.
            yield SendTaskStreamingResponse(
              id=request.id,
              result=TaskStatusUpdateEvent(
                  id=task_send_params.id,
                  status=TaskStatus(
                      state=task_status.state,
                  ),
                  final=True
              )
            )

        # --- Handle Errors ---
        except Exception as e:
            # Log the error and yield a JSONRPC error response to the client.
            logger.error(f"An error occurred while streaming the response: {e}")
            yield JSONRPCResponse(
                id=request.id,
                error=InternalError(
                    message="An error occurred while streaming the response"
                ),
            )

    def _validate_request(
        self, request: Union[SendTaskRequest, SendTaskStreamingRequest]
    ) -> None:
        """
        Validates the given SendTaskRequest or SendTaskStreamingRequest.

        Checks if the requested output modes are compatible with the agent's
        supported content types.  Logs a warning and returns an error if not compatible.

        Args:
            request: The SendTaskRequest or SendTaskStreamingRequest to validate.

        Returns:
            None if the request is valid, otherwise a JSONRPCResponse containing an error.
        """
        task_send_params: TaskSendParams = request.params
        if not utils.are_modalities_compatible(
            task_send_params.acceptedOutputModes, self.agent.SUPPORTED_CONTENT_TYPES
        ):
            logger.warning(
                "Unsupported output mode. Received %s, Support %s",
                task_send_params.acceptedOutputModes,
                self.agent.SUPPORTED_CONTENT_TYPES,
            )
            return utils.new_incompatible_types_error(request.id)

    async def on_send_task(self, request: SendTaskRequest) -> SendTaskResponse:
        """
        Handles a SendTaskRequest.

        Validates the request, upserts the task, and then invokes the agent.

        Args:
            request: The SendTaskRequest to handle.

        Returns:
            A SendTaskResponse containing the result of the task execution.
        """
        error = self._validate_request(request)
        if error:
            return error
        await self.upsert_task(request.params)
        return await self._invoke(request)

    async def on_send_task_subscribe(
        self, request: SendTaskStreamingRequest
    ) -> AsyncIterable[SendTaskStreamingResponse] | JSONRPCResponse:
        """
        Handles a SendTaskStreamingRequest.

        Validates the request, upserts the task, and then starts streaming the
        results from the agent.

        Args:
            request: The SendTaskStreamingRequest to handle.

        Returns:
            An AsyncIterable of SendTaskStreamingResponse objects representing the
            stream of results from the agent, or a JSONRPCResponse in case of error.
        """
        error = self._validate_request(request)
        if error:
            return error
        await self.upsert_task(request.params)
        return self._stream_generator(request)

    async def _update_store(
        self, task_id: str, status: TaskStatus, artifacts: list[Artifact]
    ) -> Task:
        """
        Updates the task's status and artifacts in the task store.

        Args:
            task_id: The ID of the task to update.
            status: The new TaskStatus for the task.
            artifacts: A list of Artifact objects to add to the task.

        Returns:
            The updated Task object.

        Raises:
            ValueError: If the task is not found in the task store.
        """
        async with self.lock:
            try:
                task = self.tasks[task_id]
            except KeyError:
                logger.error(f"Task {task_id} not found for updating the task")
                raise ValueError(f"Task {task_id} not found")
            task.status = status
            if artifacts is not None:
                if task.artifacts is None:
                    task.artifacts = []
                task.artifacts.extend(artifacts)
            return task

    async def _invoke(self, request: SendTaskRequest) -> SendTaskResponse:
        """
        Invokes the agent for a given SendTaskRequest.

        Extracts the user query from the request, invokes the agent's invoke
        method, and then updates the task store with the result.

        Args:
            request: The SendTaskRequest to process.

        Returns:
            A SendTaskResponse containing the result of the agent invocation.
        """
        task_send_params: TaskSendParams = request.params
        query = self._get_user_query(task_send_params)
        try:
            result = self.agent.invoke(query, task_send_params.sessionId)
        except Exception as e:
            logger.error(f"Error invoking agent: {e}")
            raise ValueError(f"Error invoking agent: {e}")
        parts = [{"type": "text", "text": result}]
        task_state = TaskState.INPUT_REQUIRED if "MISSING_INFO:" in result else TaskState.COMPLETED
        task = await self._update_store(
            task_send_params.id,
            TaskStatus(
                state=task_state, message=Message(role="agent", parts=parts)
            ),
            [Artifact(parts=parts)],
        )
        return SendTaskResponse(id=request.id, result=task)

    def _get_user_query(self, task_send_params: TaskSendParams) -> str:
        """
        Extracts the user query from the TaskSendParams.

        Args:
            task_send_params: The TaskSendParams object.

        Returns:
            The user query as a string.

        Raises:
            ValueError: If the message part is not a TextPart.
        """
        part = task_send_params.message.parts[0]
        if not isinstance(part, TextPart):
            raise ValueError("Only text parts are supported")
        return part.text
